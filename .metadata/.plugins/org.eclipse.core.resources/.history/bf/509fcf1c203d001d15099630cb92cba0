/*
 * pwm.c
 *
 *  Created on: 24/09/2022
 *      Author: daniel
 */

#include "stm32l4xx.h"


#define TIM2EN				(1U<<0)															//Enable Timer 2 Clock Access
#define CR1_CEN				(1U<<0)																//Enable counter

#define GPIOEN				(1U<<4)																//Enable clock access to GPIO

void initialize_GPIOE(){
	//Configure PA0 as Alterative function
	GPIOA->MODER &=~	(1U<<0); //Coloca no pino 0 o valor 1 negado ou seja 0
	GPIOA->MODER |=		(1U<<1);
	//Configure PA0 as push-pull
	GPIOA->OTYPER &=~	(1u<<0);
	//Configure PA0 as very high speed
	GPIOA->OSPEEDR |=	(1U<<0);
	GPIOA->OSPEEDR |=	(1U<<1);
	//Configure AF1 low register
	GPIOA->AFR[0]  |=	(1U<<0);
	GPIOA->AFR[0]  &=~	(1U<<1);
	GPIOA->AFR[0]  &=~	(1U<<2);
	GPIOA->AFR[0]  &=~	(1U<<3);
	//Configure AF1 high register
	GPIOA->AFR[1]  |=	(1U<<0);
	GPIOA->AFR[1]  &=~	(1U<<1);
	GPIOA->AFR[1]  &=~	(1U<<2);
	GPIOA->AFR[1]  &=~	(1U<<3);
	//Force diconnect imput to the adc
	GPIOA->ASCR	   &=~	(1U<<0);
}
void pwm(void)
{
	initialize_GPIOE();

	//Enable APB2 Clock access to Timer 2
	RCC->APB1ENR1 |= TIM2EN;

	//Frequency determined by TIMx_ARR
	TIM2->ARR = 10;
	//Duty cycle determined by TIMx_CCRx
	TIM2->CCR1 = 50;



	//PWM mode 1 - In upcounting, channel 1 is active as long as TIMx_CNT<TIMx_CCR1 else inactive
	TIM2->CCMR1	&=~	(1U<<4);
	TIM2->CCMR1	|=	(1U<<5);
	TIM2->CCMR1	|=	(1U<<6);
	TIM2->CCMR1	&=~	(1U<<16);

	//DIR -> 0: Counter used as upcounter
	TIM2->CR1	&=~ (1<<4);
	//TIMx_ARR register is not buffered
	TIM2->CR1	&=~	(1U<<7);
	//UG-> Update generation 1: Re-initialize the counter and generates an update of the registers
	TIM2->EGR	|= 	(1U<<0);


}
